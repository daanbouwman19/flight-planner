//! Mock data generator for benchmarks
//!
//! This module generates consistent, seeded mock airport data that statistically matches
//! a real airport database for accurate performance benchmarking.
//!
//! **Data Sources:**
//! - Aircraft: Loaded from actual `aircrafts.csv` file in the repository
//! - Airports: Generated based on statistical analysis of real airports
//! - Runways: Generated based on statistical analysis of real runways
//!
//! **Statistical Accuracy:**
//! All distributions are based on percentile analysis of the real database:
//! - Elevation distribution (percentile-based: P25, P50, P75, P90, P95)
//! - Runway count per airport (majority have 2 runways, matching real distribution)
//! - Runway length distribution (percentile-based from short to very long)
//! - Runway width distribution (percentile-based)
//! - Surface type distribution (ASP, GRE, WAT, U with exact percentages)
//! - Geographic distribution (global coverage produces realistic inter-airport distances)
//!
//! **Reproducibility:**
//! Fixed seed ensures deterministic output across runs for reliable benchmarking.
//!
//! **Regeneration:**
//! Run `analyze_airport_database.py` to regenerate statistics if the real database changes.

#[cfg(feature = "gui")]
pub use internal::*;

#[cfg(feature = "gui")]
mod internal {
    #![allow(dead_code)] // Module used by benchmark.rs

    use flight_planner::models::{Aircraft, Airport, Runway};
    use rand::rngs::StdRng;
    use rand::{Rng, SeedableRng};
    use std::collections::HashMap;
    use std::sync::Arc;

    const SEED: u64 = 42; // Fixed seed for reproducibility
    const AIRCRAFTS_CSV_PATH: &str = "aircrafts.csv";

    // ============================================================================
    // Database Statistics Constants
    // Generated by analyze_airport_database.py
    // ============================================================================

    /// Default airport count based on real database size
    pub const DEFAULT_AIRPORT_COUNT: usize = 16343;

    /// Elevation distribution constants (feet)
    const ELEVATION_MIN: i32 = -210;
    const ELEVATION_MAX: i32 = 14422;
    const ELEVATION_P25: i32 = 179;
    const ELEVATION_P50: i32 = 710;
    const ELEVATION_P75: i32 = 1489;
    const ELEVATION_P90: i32 = 3018;
    const ELEVATION_P95: i32 = 4360;

    /// Geographic distribution constants
    const LATITUDE_MIN: f64 = -89.98;
    const LATITUDE_MAX: f64 = 82.52;
    const LONGITUDE_MIN: f64 = -179.88;
    const LONGITUDE_MAX: f64 = 179.95;

    /// Runway count distribution [(count, cumulative_probability)]
    const RUNWAY_COUNT_DISTRIBUTION: &[(i32, f64)] = &[
        (1, 0.0001),  // 0.01%
        (2, 0.7981),  // 79.80%
        (3, 0.7983),  // 0.02%
        (4, 0.9665),  // 16.82%
        (5, 0.9667),  // 0.02%
        (6, 0.9934),  // 2.67%
        (7, 0.9935),  // 0.01%
        (8, 0.9985),  // 0.50%
        (10, 0.9994), // 0.09%
        (12, 0.9999), // 0.04%
        (14, 0.9999), // 0.01%
        (16, 1.0000), // 0.01%
    ];

    /// Runway length distribution constants (feet)
    const RUNWAY_LENGTH_MIN: i32 = 80;
    const RUNWAY_LENGTH_MAX: i32 = 21119;
    const RUNWAY_LENGTH_P25: i32 = 2700;
    const RUNWAY_LENGTH_P50: i32 = 3937;
    const RUNWAY_LENGTH_P75: i32 = 5906;
    const RUNWAY_LENGTH_P90: i32 = 8999;

    /// Runway width distribution constants (feet)
    const RUNWAY_WIDTH_MIN: i32 = 9;
    const RUNWAY_WIDTH_MAX: i32 = 999;
    const RUNWAY_WIDTH_P25: i32 = 70;
    const RUNWAY_WIDTH_P50: i32 = 98;
    const RUNWAY_WIDTH_P75: i32 = 148;
    const RUNWAY_WIDTH_P90: i32 = 150;

    /// Surface type distribution [(surface, cumulative_probability)]
    const SURFACE_TYPE_DISTRIBUTION: &[(&str, f64)] = &[
        ("ASP", 0.7000), // 70.00%
        ("GRE", 0.9940), // 29.40%
        ("WAT", 0.9997), // 0.57%
        ("U", 1.0000),   // 0.03%
    ];

    /// Load aircraft from the repository's aircrafts.csv file
    pub fn load_aircraft_from_csv() -> Result<Vec<Arc<Aircraft>>, Box<dyn std::error::Error>> {
        let mut reader = csv::Reader::from_path(AIRCRAFTS_CSV_PATH)?;
        let mut aircraft = Vec::new();

        for (id, result) in reader.records().enumerate() {
            let record = result?;

            if record.len() < 9 {
                continue; // Skip malformed lines
            }

            let manufacturer = record.get(0).unwrap_or("").to_string();
            let variant = record.get(1).unwrap_or("").to_string();
            let icao_code = record.get(2).unwrap_or("").to_string();
            let flown: i32 = record.get(3).unwrap_or("0").parse().unwrap_or(0);
            let aircraft_range: i32 = record.get(4).unwrap_or("0").parse().unwrap_or(0);
            let category = record.get(5).unwrap_or("").to_string();
            let cruise_speed: i32 = record.get(6).unwrap_or("0").parse().unwrap_or(0);
            let date_flown = record
                .get(7)
                .filter(|s| !s.is_empty())
                .map(|s| s.to_string());
            let takeoff_distance: Option<i32> = record.get(8).and_then(|s| s.parse().ok());

            aircraft.push(Arc::new(Aircraft {
                id: id as i32,
                manufacturer,
                variant,
                icao_code,
                flown,
                aircraft_range,
                category,
                cruise_speed,
                date_flown,
                takeoff_distance,
            }));
        }

        Ok(aircraft)
    }

    /// Generate a set of mock airports with consistent seeded randomness
    ///
    /// Based on real database statistics:
    /// - Elevation: Percentile-based distribution matching real data
    /// - Geographic spread: Global coverage (full latitude/longitude range)
    /// - Distance between airports: Natural distribution from uniform global spread
    /// - Uses weighted percentile-based distribution for realistic characteristics
    pub fn generate_mock_airports(count: usize) -> Vec<Arc<Airport>> {
        if count > 1_000_000 {
            panic!(
                "Requested airport count {} exceeds safety limit of 1,000,000",
                count
            );
        }
        let mut rng = StdRng::seed_from_u64(SEED);
        let mut airports = Vec::with_capacity(count);

        for id in 0..count {
            // Generate simple airport identifiers
            // Names don't affect benchmark performance, so keep them simple
            let name = format!("Mock Airport {}", id + 1);

            // Generate ICAO code: 4 random letters for global coverage
            let icao = format!(
                "{}{}{}{}",
                (b'A' + rng.random_range(0..26)) as char,
                (b'A' + rng.random_range(0..26)) as char,
                (b'A' + rng.random_range(0..26)) as char,
                (b'A' + rng.random_range(0..26)) as char
            );

            // Global distribution matching real database coverage
            // Note: Real database has latitude range -90° to +83° (not full -90 to +90)
            let latitude = rng.random_range(LATITUDE_MIN..=LATITUDE_MAX);
            let longitude = rng.random_range(LONGITUDE_MIN..=LONGITUDE_MAX);

            // Realistic elevation distribution based on percentile analysis
            let elevation_rand = rng.random::<f64>();
            let elevation = if elevation_rand < 0.25 {
                rng.random_range(ELEVATION_MIN..ELEVATION_P25) // P0-P25: Sea level and below
            } else if elevation_rand < 0.50 {
                rng.random_range(ELEVATION_P25..ELEVATION_P50) // P25-P50: Low elevation
            } else if elevation_rand < 0.75 {
                rng.random_range(ELEVATION_P50..ELEVATION_P75) // P50-P75: Medium elevation
            } else if elevation_rand < 0.90 {
                rng.random_range(ELEVATION_P75..ELEVATION_P90) // P75-P90: High elevation
            } else if elevation_rand < 0.95 {
                rng.random_range(ELEVATION_P90..ELEVATION_P95) // P90-P95: Very high elevation
            } else {
                rng.random_range(ELEVATION_P95..ELEVATION_MAX) // P95-P100: Extreme elevation
            };

            airports.push(Arc::new(Airport {
                ID: id as i32,
                Name: name,
                ICAO: icao,
                PrimaryID: Some(id as i32),
                Latitude: latitude,
                Longtitude: longitude,
                Elevation: elevation,
                TransitionAltitude: Some(18000),
                TransitionLevel: Some(180),
                SpeedLimit: Some(250),
                SpeedLimitAltitude: Some(10000),
            }));
        }

        airports
    }

    /// Generate a set of mock runways for the given airports
    ///
    /// Based on real database statistics:
    /// - Runway count distribution: Percentile-based (majority have 2 runways)
    /// - Length: Percentile-based distribution from short to very long
    /// - Width: Percentile-based distribution
    /// - Surface types: Accurate distribution of ASP, GRE, WAT, U
    pub fn generate_mock_runways(airports: &[Arc<Airport>]) -> HashMap<i32, Arc<Vec<Runway>>> {
        let mut rng = StdRng::seed_from_u64(SEED + 1);
        let mut runways_map = HashMap::new();

        for airport in airports {
            // Realistic runway count distribution based on actual database percentiles
            let runway_rand = rng.random::<f64>();
            let num_runways = RUNWAY_COUNT_DISTRIBUTION
                .iter()
                .find(|(_, prob)| runway_rand < *prob)
                .map(|(count, _)| *count)
                .unwrap_or(RUNWAY_COUNT_DISTRIBUTION.last().unwrap().0);

            let mut runways = Vec::new();

            for runway_idx in 0..num_runways {
                // Runways are typically oriented based on prevailing winds
                // For simulation, we'll use evenly distributed headings
                let base_heading = (runway_idx as f64 * 360.0 / num_runways as f64) as i32;
                let heading = base_heading % 360;
                // Round to nearest 10 degrees and ensure valid runway number (1-36)
                let runway_number = match ((heading + 5) / 10) % 36 {
                    0 => 36,
                    n => n,
                };

                // Determine parallel runway suffix if multiple runways exist
                let suffix = if num_runways > 2 {
                    match runway_idx % 3 {
                        0 => "L",
                        1 => "C",
                        _ => "R",
                    }
                } else if num_runways == 2 {
                    if runway_idx == 0 { "L" } else { "R" }
                } else {
                    ""
                };

                let ident = format!("{:02}{}", runway_number, suffix);

                // Realistic runway length distribution based on percentiles
                let length_rand = rng.random::<f64>();
                let base_length = if length_rand < 0.25 {
                    rng.random_range(RUNWAY_LENGTH_MIN..RUNWAY_LENGTH_P25) // P0-P25
                } else if length_rand < 0.50 {
                    rng.random_range(RUNWAY_LENGTH_P25..RUNWAY_LENGTH_P50) // P25-P50
                } else if length_rand < 0.75 {
                    rng.random_range(RUNWAY_LENGTH_P50..RUNWAY_LENGTH_P75) // P50-P75
                } else if length_rand < 0.90 {
                    rng.random_range(RUNWAY_LENGTH_P75..RUNWAY_LENGTH_P90) // P75-P90
                } else {
                    rng.random_range(RUNWAY_LENGTH_P90..RUNWAY_LENGTH_MAX) // P90-P100
                };

                // High altitude airports need extra runway length (thinner air)
                let length = if airport.Elevation > 3000 {
                    (base_length as f64 * 1.15) as i32 // 15% longer at high altitude
                } else {
                    base_length
                };

                // Realistic runway width distribution based on percentiles
                let width_rand = rng.random::<f64>();
                let width = if width_rand < 0.25 {
                    rng.random_range(RUNWAY_WIDTH_MIN..RUNWAY_WIDTH_P25) // P0-P25
                } else if width_rand < 0.50 {
                    rng.random_range(RUNWAY_WIDTH_P25..RUNWAY_WIDTH_P50) // P25-P50
                } else if width_rand < 0.75 {
                    rng.random_range(RUNWAY_WIDTH_P50..RUNWAY_WIDTH_P75) // P50-P75
                } else {
                    rng.random_range(RUNWAY_WIDTH_P75..RUNWAY_WIDTH_P90) // P75-P90
                };

                // Surface type distribution based on database percentages
                let surface_rand = rng.random::<f64>();
                let surface = SURFACE_TYPE_DISTRIBUTION
                    .iter()
                    .find(|(_, prob)| surface_rand < *prob)
                    .map(|(surf, _)| *surf)
                    .unwrap_or(SURFACE_TYPE_DISTRIBUTION[0].0);

                runways.push(Runway {
                    ID: (airport.ID * 10 + runway_idx),
                    AirportID: airport.ID,
                    Ident: ident,
                    TrueHeading: heading as f64,
                    Length: length,
                    Width: width,
                    Surface: surface.to_string(),
                    Latitude: airport.Latitude,
                    Longtitude: airport.Longtitude,
                    Elevation: airport.Elevation,
                });
            }

            runways_map.insert(airport.ID, Arc::new(runways));
        }

        runways_map
    }

    /// Generate an R-tree for spatial airport queries
    pub fn generate_spatial_rtree(
        airports: &[Arc<Airport>],
    ) -> rstar::RTree<flight_planner::models::airport::SpatialAirport> {
        use flight_planner::models::airport::SpatialAirport;

        // We need runways to calculate longest_runway_length for each airport
        // Re-generate them here (deterministic because of seeded RNG) since we don't have them passed in
        // Note: In production code we pass them, but here it's cleaner to regenerate than change function signature extensively
        let runways_map = generate_mock_runways(airports);

        let spatial_airports: Vec<SpatialAirport> = airports
            .iter()
            .map(|airport| {
                let longest_runway_length = runways_map
                    .get(&airport.ID)
                    .map(|runways| runways.iter().map(|r| r.Length).max().unwrap_or(0))
                    .unwrap_or(0);

                SpatialAirport {
                    airport: flight_planner::models::airport::CachedAirport::new(
                        Arc::clone(airport),
                        longest_runway_length,
                    ),
                }
            })
            .collect();

        rstar::RTree::bulk_load(spatial_airports)
    }
}

// This file is a module used by benchmark.rs, not a standalone example
// The main function is required by Cargo but not used
#[allow(dead_code)]
fn main() {}
